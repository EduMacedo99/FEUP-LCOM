#include <lcom/lcf.h>
#include <stdint.h>
#include <stdio.h>
#include <math.h>
#include <machine/int86.h>
#include "video.h"
#include "v_macros.h"

static void *video_mem;		/* Process (virtual) address to which VRAM is mapped */

static unsigned h_res;	        /* Horizontal resolution in pixels */
static unsigned v_res;	        /* Vertical resolution in pixels */
static unsigned bits_per_pixel; /* Number of VRAM bits per pixel */
static unsigned color_mode;     /* Value of the color mode */
static unsigned bytes_per_pixel; /* Number of bytes a pixel ocuppies, in a certain video mode */

int r;
struct minix_mem_range mr;
static unsigned int vram_base;  /* VRAM's physical addresss */
static unsigned int vram_size;  /* VRAM's size, but you can use the frame-buffer size, instead */

static unsigned RedMaskSize;
static unsigned RedFieldPosition;
static unsigned GreenMaskSize;
static unsigned GreenFieldPosition;
static unsigned BlueMaskSize;
static unsigned BlueFieldPosition;

unsigned get_color_mode(){
  return color_mode;
}


unsigned get_h_res(){
  return h_res;
}


unsigned get_v_res(){
  return v_res;
}


unsigned get_bitspp(){
  return bits_per_pixel;
}

unsigned get_bytespp(){
  return bytes_per_pixel;
}

struct minix_mem_range get_minix_memory_range(){
  return mr;
}


unsigned int get_vram_base(){
  return vram_base;
}


unsigned int get_vram_size(){
  return vram_size;
}

void* get_video_mem(){
  return video_mem;
}


int vbe_get_info_about_mode(uint16_t mode, vbe_mode_info_t *vmi_p){

  if(lm_init(false) == NULL){
    printf("lm_init failed!\n");
    return 1;
  }

  phys_bytes buf;
  mmap_t map;
  struct reg86u reg86;

  memset(&reg86, 0, sizeof(reg86)); //clears the structure

  unsigned num_tries = 0;

  //tries to use lm_alloc(); if it fails a max number of times, terminates the program
  while(num_tries < ALLOC_MAX_TRIES){

    if(lm_alloc(sizeof(vbe_mode_info_t), &map) == NULL)
      num_tries++;
    else{
      num_tries = 0;
      break;
    }
  }

  if(num_tries == ALLOC_MAX_TRIES){
    printf("lm_alloc failed!\n");
    return 1;
  }

  buf = map.phys;

  reg86.u.b.intno = VID_CARD_I_VEC;
  reg86.u.w.ax = RET_VBE_MODE; //0x4F01
  reg86.u.w.es = PB2BASE(buf);
  reg86.u.w.di = PB2OFF(buf);
  reg86.u.w.cx = mode;

  if( sys_int86(&reg86) != OK ) {
    printf("\tvg_exit(): sys_int86() failed \n");
    return 1;
  }

  //ah register is set to 0 if everything was sucessful
  if(reg86.u.b.ah != 0)
    return 1;

  //the struct variable now has all the information needed
  *vmi_p = *((vbe_mode_info_t*) map.virt);

  if(!lm_free(&map)){
    printf("lm_free failed!\n");
    return 1;
  }
  
  return 0;
}


int set_graph_mode(uint16_t mode){

  struct reg86u reg86;

  memset(&reg86, 0, sizeof(reg86)); //clears the structure

  reg86.u.b.intno = VID_CARD_I_VEC;
  reg86.u.w.ax = SET_VBE_MODE; //0x4F02
  reg86.u.w.bx = SET_LINEAR_FB | mode;


  if( sys_int86(&reg86) != OK ) {
    printf("\tvg_exit(): sys_int86() failed \n");
    return 1;
  }

  //ah register is set to 0 if everything was sucessful
  if(reg86.u.b.ah != 0)
    return 1;

  return 0;
}


int get_vram_info(uint16_t mode){

  vbe_mode_info_t vmi_p;

  if(vbe_get_info_about_mode(mode, &vmi_p) != 0)
    return 1;

  h_res = vmi_p.XResolution; //updates hor resolution
  v_res = vmi_p.YResolution;  //updates vert resolution
  bits_per_pixel = vmi_p.BitsPerPixel; //updates the bits per pixel
  vram_base = vmi_p.PhysBasePtr;  //updates the vram physical address
  color_mode = vmi_p.MemoryModel; //updates the color mode
  
  RedMaskSize = vmi_p.RedMaskSize;
  RedFieldPosition = vmi_p.RedFieldPosition;
  GreenMaskSize = vmi_p.GreenMaskSize;
  GreenFieldPosition = vmi_p.GreenFieldPosition;
  BlueMaskSize = vmi_p.BlueMaskSize;
  BlueFieldPosition = vmi_p.BlueFieldPosition;

  bytes_per_pixel = bits_per_pixel;

  //number is not even
  if((bytes_per_pixel % 2) != 0)
    bytes_per_pixel++;

  bytes_per_pixel /= 8;

  vram_size = h_res * v_res * bytes_per_pixel; //updates the vram's size


  return 0;
}


int map_memory(){

  /* Allow memory mapping */

  mr.mr_base = (phys_bytes) vram_base;	
  mr.mr_limit = mr.mr_base + vram_size;  

  if( OK != (r = sys_privctl(SELF, SYS_PRIV_ADD_MEM, &mr))){
    panic("sys_privctl (ADD_MEM) failed: %d\n", r);
    return 1;
  }
  /* Map memory */

  video_mem = vm_map_phys(SELF, (void *)mr.mr_base, vram_size);

  if(video_mem == MAP_FAILED){

   panic("couldn't map video memory");
   return 1;
  }

  return 0;

}



void* (vg_init)(uint16_t mode){

    if(get_vram_info(mode) != 0)
      return NULL;

    if(map_memory() != 0)
      return NULL;

    if(set_graph_mode(mode) != 0)
      return NULL;

    return video_mem;
}



int color_pixel(uint16_t x, uint16_t y, uint32_t color){

  //checks if valid x value
  if( x >= get_h_res() ){

    printf("invalid x value!\n");
    return 1;
  }

  //checks if valid y value
  if( y >= get_v_res() ){

    printf("invalid y value!\n");
    return 1;
  }


  uint8_t* ptr = video_mem;

  //puts the pointer on the desired line
  ptr += (get_h_res() * y * get_bytespp());

  //puts the pointer on the desired pixel
  ptr += (x * get_bytespp());

  //writes the color value in the given pixel
  for(unsigned j = 0; j < get_bytespp(); j++, ptr++){

    *ptr = (uint8_t)(color >> j * 8);
  }

  //----------

  //*ptr = color;

  //---------

  /*char *ptr_VM = video_mem;

	//contas
	ptr_VM += (x + h_res * y) * (bits_per_pixel / 8);

	*ptr_VM = color;
	return 0;*/

  //-----------

  /*if ( (x<0) || (y<0) || (x>=h_res) || (y>=v_res))
        return 1;

    // Compute the no. of bytes per pixel
    u_char bytes_per_pixel = bits_per_pixel / 8;

  char* ptr = video_mem;

    // Draw the pixel with the desired color
    if (bytes_per_pixel == 1)
        *(ptr + (y*h_res*bytes_per_pixel) + (x*bytes_per_pixel) ) = (unsigned char) color;
    else
        *(ptr + (y*h_res*bytes_per_pixel) + (x*bytes_per_pixel) ) = color;*/


  return 0;
}


int (vg_draw_hline)(uint16_t x, uint16_t y, uint16_t len, uint32_t color){

  //checks if valid x value
  if( x >= get_h_res() ){

    printf("invalid x value!\n");
    return 1;
  }

  //checks if valid y value
  if( y >= get_v_res() ){

    printf("invalid y value!\n");
    return 1;
  }
  
  //checks if value length value
  if( (x + len) > get_h_res() ){

    printf("invalid length value!\n");
    return 1;
  }

  //checks if valid color
  if(color >= pow(2, get_bitspp() )){

      printf("invalid color value!\n");
      return 1;
  }


  //draws the line
  for(unsigned i = 0; i < len; i++){
   
      if(color_pixel(x + i, y, color) != 0){

        printf("Drawing of the line failed!\n");
        return 1;
     }

  }

    return 0;
}



int (vg_draw_rectangle)(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color){

  //checks if valid height value
  if((y + height) > get_v_res() ){

    printf("invalid height value!\n");
    return 1;
  }

  for(int i = 0; i < height; i++){

    if(vg_draw_hline(x, y + i, width, color) != 0)
      return 1;
  
  }

  return 0;
}


uint8_t return_color_comp(unsigned field_position, unsigned mask_size, uint32_t color){

  uint32_t newC = color >> field_position;
  
  return get_less_bits(newC, mask_size);
}


uint32_t change_color(uint16_t row, uint16_t col, uint8_t no_rectangles, uint32_t first, uint8_t step){

  //for indexed color mode
  if(color_mode == INDEX_CLR_MODE){

    uint32_t color = ((first + (row * no_rectangles + col) * step) % (1 << bits_per_pixel));

    return color;

  } //for direct color mode
  else if(color_mode == DIR_CLR_MODE){

    uint8_t redComp = return_color_comp(RedFieldPosition, RedMaskSize, first);
    uint8_t greenComp = return_color_comp(GreenFieldPosition, GreenMaskSize, first);
    uint8_t blueComp = return_color_comp(BlueFieldPosition, BlueMaskSize, first);

    //values of the color components of the first color
    /*uint8_t redComp;
    uint8_t blueComp;
    uint8_t greenComp;

    uint32_t color = first;

    //red is the first color
    if(RedFieldPosition == 0){

        
        redComp = get_less_bits(color, RedMaskSize);
        color >>= RedMaskSize;

        //first red, then blue, then green
        if(BlueFieldPosition < GreenFieldPosition){

          blueComp = get_less_bits(color, BlueMaskSize);
          color >>= BlueMaskSize;

          greenComp = get_less_bits(color, GreenMaskSize);

        }//first red, then green, then blue
        else{

           greenComp = get_less_bits(color, GreenMaskSize);
           color >>= GreenMaskSize;

           blueComp = get_less_bits(color, BlueMaskSize);
        }

    }//blue is the first color
    else if(BlueFieldPosition == 0){

        blueComp = get_less_bits(color, BlueMaskSize);
        color >>= BlueMaskSize;

      //first blue, then red, then green
      if(RedFieldPosition < GreenFieldPosition){

         redComp = get_less_bits(color, RedMaskSize);
         color >>= RedMaskSize;

         greenComp = get_less_bits(color, GreenMaskSize);

      }//first blue, then green, then red
      else{

        greenComp = get_less_bits(color, GreenMaskSize);
        color >>= GreenMaskSize;

        redComp = get_less_bits(color, RedMaskSize);
      }
    
    }//green is the first color
    else{

      greenComp = get_less_bits(color, GreenMaskSize);
      color >>= GreenMaskSize;

      //first green, then red, then blue
      if(RedFieldPosition < BlueFieldPosition){

         redComp = get_less_bits(color, RedMaskSize);
         color >>= RedMaskSize;

         blueComp = get_less_bits(color, BlueMaskSize);

      }//first green, then blue, then red
      else{

        blueComp = get_less_bits(color, BlueMaskSize);
        color >>= BlueMaskSize;

        redComp = get_less_bits(color, RedMaskSize);

      }

    }*/

    uint8_t redPart = (redComp + col * step) % (1 << RedMaskSize);
    uint8_t greenPart = (greenComp + row * step) % (1 << GreenMaskSize);
    uint8_t bluePart = (blueComp + (col + row) * step) % (1 << BlueMaskSize);

    uint32_t finalColor = (redPart << RedFieldPosition) | (greenPart << GreenFieldPosition) | (bluePart << BlueFieldPosition);

    return finalColor;
  }
  else{
    printf("Error with the color mode! (Not index nor direct\n");
    return 1;

  }

}

int clear_screen(){
 
  uint8_t* ptr = video_mem;

 for (unsigned i=0 ; i < h_res*v_res ; i++)
    *(ptr +i) = 0;

    return 0;
}


uint8_t get_less_bits(uint32_t value, uint32_t num_bits){

  value <<= (32 - num_bits);
  value >>= (32 - num_bits);

  return value;
}


int draw_pixmap(const char* sprite, uint16_t x, uint16_t y, int width, int height){

unsigned int xf = x; 
unsigned int yf = y;

//Checks for invalid height and width values
 if((yf + height) > get_v_res() ){

    printf("invalid height value!\n");
    return 1;
  }

    if( (xf + width) > get_h_res() ){

    printf("invalid length value!\n");
    return 1;
  }

//draws the xpm
 for(int i = 0; i < height; i++){

    for(int j = 0; j < width; j++){
      //(sprite + i*width + j) -> to access the position w/ the correct color 
      if(color_pixel(xf, yf, *(sprite + i*width + j)) != 0){

        printf("Drawing of the pixmap failed!\n");
        return 1;
     }
    xf++;             //moves one pixel
    }
     yf++;            //Next line
     xf = xf - width; //Goes back to the original collumn
 }


  return 0;
}

int erase_pixmap(uint16_t x, uint16_t y, int width, int height){

unsigned int xf = x; 
unsigned int yf = y;

//Checks for invalid height and width values
 if((yf + height) > get_v_res() ){

    printf("invalid height value!\n");
    return 1;
  }

    if((xf + width) > get_h_res() ){

    printf("invalid length value!\n");
    return 1;
  }

 for(int i = 0; i < height; i++){

    for(int j = 0; j < width; j++){
     
      //puts the desired pixel in black
      if(color_pixel(xf, yf, 0) != 0){

        printf("Erasing of the pixmap failed!\n");
        return 1;
     }
    xf++;             //moves one pixel
    }
     yf++;            //Next line
     xf = xf - width; //Goes back to the original collumn
 }


  return 0;
}

int vbe_get_ctrl_info(vg_vbe_contr_info_t *ctrl_info){

  if(lm_init(false) == NULL){
    printf("lm_init failed!\n");
    return 1;
  }

  phys_bytes buf;
  mmap_t map;
  struct reg86u reg86;
  //vbe_info_block_t *info_block;

  memset(&reg86, 0, sizeof(reg86)); //clears the structure

  unsigned num_tries = 0;

  //tries to use lm_alloc(); if it fails a max number of times, terminates the program
  while(num_tries < ALLOC_MAX_TRIES){

    if(lm_alloc(sizeof(vbe_info_block_t), &map) == NULL)
      num_tries++;
    else{
      num_tries = 0;
      break;
    }
  }

  if(num_tries == ALLOC_MAX_TRIES){
    printf("lm_alloc failed!\n");
    return 1;
  }

  buf = map.phys;

  reg86.u.b.intno = VID_CARD_I_VEC;
  reg86.u.w.ax = GET_VBE_CTRL_INFO; //0x4F00
  reg86.u.w.es = PB2BASE(buf);
  reg86.u.w.di = PB2OFF(buf);

  if( sys_int86(&reg86) != OK ) {
    printf("\tvg_exit(): sys_int86() failed \n");
    return 1;
  }

  //ah register is set to 0 if everything was sucessful
  if(reg86.u.b.ah != 0)
    return 1;

  //the struct variable now has all the information needed  
  //*info_block = *((vbe_info_block_t*) map.virt);

  if(!lm_free(&map)){
    printf("lm_free failed!\n");
    return 1;
  }

  //fazer
  ctrl_info = 0;

  return 0;
}
